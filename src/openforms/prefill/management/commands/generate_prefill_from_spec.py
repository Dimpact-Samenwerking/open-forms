import os.path
from dataclasses import dataclass
from typing import List, Tuple

from django.core.management import BaseCommand

import black
from glom import GlomError, Path, glom
from zds_client.oas import SchemaFetcher
from zgw_consumers.models import Service


def json_path(obj, reference):
    # simplistic json-path
    if reference[:2] == "#/":
        split_path = reference[2:].split("/")
        tmp = obj
        for parent in split_path:
            tmp = tmp.get(parent)

        return tmp

    raise NotImplementedError()


@dataclass()
class Choice:
    name: str
    path: str
    labels: Tuple[str]


simple_types = (
    "string",
    "integer",
    "number",
    "boolean",
)
preferred_content_types = [
    "application/hal+json",
    "application/json",
]


def select_call(root_schema, api_path):
    try:
        content_types = glom(
            root_schema, Path("paths", api_path, "get", "responses", "200", "content")
        )
    except GlomError as e:
        print(e)
        return

    for t in preferred_content_types:
        try:
            return content_types[t]
        except KeyError:
            pass
    return None


def generate_prefill_from_spec_url(url, api_path, output):
    schema_fetcher = SchemaFetcher()
    root_schema = schema_fetcher.fetch(url)

    # find the call with the http parameters we're interested in
    content_type = select_call(root_schema, api_path)

    if not content_type:
        raise NotImplementedError(
            f"cannot find suitable content-type: {preferred_content_types}"
        )

    if "$ref" in content_type["schema"]:
        ref = content_type["schema"]["$ref"]
        schema = json_path(root_schema, ref)
    else:
        schema = content_type["schema"]

    props = list()

    generate_prefill_from_schema(root_schema, props, schema)

    command = os.path.splitext(os.path.basename(__file__))[0]

    output.append("from django.utils.translation import gettext_lazy as _")
    output.append("from djchoices import ChoiceItem, DjangoChoices")
    output.append("")
    output.append("class Attributes(DjangoChoices):")
    output.append(f'    """')
    output.append(
        f"    NOTE: this was generated by 'manage.py {command}' from a Dutch API spec so labels are Dutch"
    )
    output.append(f"    spec: {url}")
    output.append(f"    path: {api_path}")
    output.append(f'    """')
    output.append("")

    for c in sorted(props, key=lambda o: o.name):
        label = " > ".join(c.labels)
        label = f'_("{label}")'
        output.append(f'    {c.name} = ChoiceItem("{c.path}", {label})')


def generate_prefill_from_schema(
    root_schema: dict,
    props: List,
    schema: dict,
    parent: str = "",
    labels: Tuple[str] = None,
):
    if schema["type"] == "object":
        for prop, sub_schema in schema["properties"].items():
            if "." in prop:
                # supporting this was out of scope at the time
                # see note with possible solution: https://github.com/open-formulieren/open-forms/pull/384/files#r644045666
                raise NotImplementedError(
                    "properties cannot contain '.' without modifications to the code ("
                )

            if "$ref" in sub_schema:
                sub_schema = json_path(root_schema, sub_schema["$ref"])
                if parent:
                    key = f"{parent}._embedded.{prop}"
                else:
                    key = f"_embedded.{prop}"
            else:
                if parent:
                    key = f"{parent}.{prop}"
                else:
                    key = prop

            label = sub_schema.get("title")
            if label:
                label = (label,)
                if labels:
                    label = labels + label
            else:
                label = labels

            if sub_schema["type"] == "object":
                generate_prefill_from_schema(root_schema, props, sub_schema, key, label)

            elif sub_schema["type"] == "array":
                # TODO array? nope
                pass

            elif sub_schema["type"] in simple_types:
                choice = Choice(
                    key.replace("_embedded.", "").replace(".", "_"),
                    key,
                    label,
                )
                props.append(choice)
            else:
                raise NotImplementedError(f"not known type: {schema['type']}")

    else:
        raise NotImplementedError(f"not object type: {schema['type']}")


class Command(BaseCommand):
    help = "Generate prefill attributes from API spec"

    def add_arguments(self, parser):
        parser.add_argument(
            "service_id",
            action="store",
            type=int,
            help="ID of a ZGWConsumers Service",
            nargs="?",
            default=None,
        )
        parser.add_argument(
            "path",
            action="store",
            type=str,
            help="API resource",
            nargs="?",
            default=None,
        )
        parser.add_argument(
            "--url",
            action="store",
            type=str,
            help="STP test URL",
            nargs="?",
            default=None,
        )

    def handle(self, **options):
        url = None
        if options["service_id"]:
            service = Service.objects.filter(id=options["service_id"]).first()
            if not service:
                self.stderr.write(
                    f"cannot find service with ID {options['service_id']}"
                )
                return
            if not service.oas:
                self.stderr.write(f"cannot find service ID {options['service_id']}")
                return
            url = service.oas
        elif options["url"]:
            url = options["url"]

        if not url:
            # be helpful and suggest services
            for service in Service.objects.order_by("id"):
                self.stdout.write(f"{service.id} {service}")
            return

        if url and not options["path"]:
            # be helpful and suggest paths
            schema = SchemaFetcher().fetch(url)
            for path, attrs in schema["paths"].items():
                self.stdout.write(path)
            return

        # run generations
        output = list()
        generate_prefill_from_spec_url(url, options["path"], output)

        # paint it black
        mode = black.FileMode()
        out = black.format_str("\n".join(output), mode=mode)
        self.stdout.write(out)
